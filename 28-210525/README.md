# Инструкция

1. Решайте задания по номерам: от `04` и далее.
2. Внутри каждого задания раскомментируйте и проходите тесты по очереди.

# Советы

## `04_memorizer`
1. В тесте `TEST_MEMORIZER_03_MEMORIZER_COPIES_ARGS`
   будьте осторожны с порядком вычислений аргументов внутри `()` — он не определён. Это может не ловиться автоматическими тестами.
1. В тесте `TEST_MEMORIZER_06_MEMORIZER_DEDUCTION_NO_REFS`
   вам может потребоваться `std::remove_reference_t`.
1. В тесте `TEST_MEMORIZER_07_MEMORIZER_SPECIFIED_ARG_REFS`:
   * Будьте осторожны: там не нужен perfect forwarding, там нужно копировать аргументы.
     Возможно, вам потребуется добавить ещё один конструктор в `CallLog`.
   * Вам может потребоваться `std::remove_reference_t`.
   * Если вы создаёте переменную внутри функции, не забудьте её замувать при необходимости.
1. В тесте `TEST_MEMORIZER_08_MEMORIZER_SPECIFIED_RET_REF`
   может оказаться удобным объявить переменную как `decltype(auto) x = ....;`

## `05_zip`
1. Используйте `std::make_index_sequence`, чтобы получить последовательность чисел от `0` до `N-1` внутри некоторого типа.
1. Используйте одну из двух техник, чтобы получить готовый к раскрытию parameter pack из типа `std::index_sequence`:
    * Вспомогательная структура и её специализация для `std::index_sequence<Indices...>`.
    * Вспомогательная (лямбда-)функция и фиктивный параметр типа `std::index_sequence<Indices...>`, а также синтаксис `[]<std::size_t ...Ns>(){}` из C++20.
