# Инструкция

1. Решайте задания в следующем порядке:
    * `conditional`
    * `any` до `ANY_TEST_06_ANY_CAST_NON_CONST` включительно
    * `stateless_manip`
    * Оставшиеся тесты `any`
2. Внутри каждого задания раскомментируйте и проходите тесты по очереди.
    * Если исходно раскомментированы все тесты, закомментируйте и открывайте по одному `TEST_CASE` сверху вниз.

# Советы
## `any`
* Тип `any` нешаблонный. А вот конструктор у него шаблонный.
* Подумайте, где хранится произвольный объект произвольного размера с учётом того, что у `any` размер фиксирован.
* Не пытайтесь сохранить внутрь `void*` и как-то хитро его научиться удалять или копировать.
  По смыслу вы хотите сохранить не указатель на произвольный объект, а указатель на объект,
  поддерживающий какие-то операции.
  Это типичный случай динамического полиморфизма и виртуальных функций.
* В районе `any_cast` всё-таки придётся добавить `void*` и `reinterpret_cast`.
* У вас не получится так просто передать массивы и функции (кроме указателей на функции) внутрь вашего `any`.
  При этом `std::any` с ними работает при помощи [`std::decay_t`](https://en.cppreference.com/w/cpp/types/decay):
  преобразует их в обычные указатели, от вас это не требуется.

## `stateless_manip`
* Забейте делать аккуратный ввод-вывод при помощи `std::istream::sentry`/`std::ostream::sentry`.
* Первый тест можно пройти, если `shifted` — это просто функция, возвращающая число или строку.
  Также можно пройти, если `shifted` — это структура с перегруженным `operator<<` и `shifted(....)` вызывает конструктор.
  Однако это не получится обобщить до второго теста.
  Лучше сделать и структуру, и функцию, которая конструирует структуру.
* Во втором тесте `shifted` должен вести себя по-разному в зависимости от того, передали ли ему временное значение или переменную.
  Как следствие, нужно завести как минимум два типа и сделать `shifted` перегруженной функцией.
  * Наследование может помочь избежать дублирования.
* Убедитесь, что строчка `s >> shifted(10, 123)` не компилируется.
